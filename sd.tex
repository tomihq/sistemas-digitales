\documentclass[10pt,a4paper]{article}
\usepackage{blindtext}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{hyperref}
\usepackage{amssymb}
\input{AEDmacros}

\title{Sistemas Digitales}
\author{Tomás Agustín Hernández}
\date{}

\begin{document}
\maketitle


\begin{figure}[b]
    \centering
    \begin{tikzpicture}[remember picture,overlay]
        \node[anchor=south east, inner sep=0pt, xshift=-1cm, yshift=2cm] at (current page.south east) {
            \begin{minipage}[b]{0.5\textwidth}
                \includegraphics[width=\linewidth]{logo_uba.jpg}
                \label{fig:bottom}
            \end{minipage}
        };
    \end{tikzpicture}
\end{figure}

\newpage

\section{Introducción a los sistemas de representación}
\subsection*{Magnitud}
Llamamos magnitud al tamaño de algo, dicho en una medida específica. 
Es representada a través de un sistema que cumple 3 conceptos fundamentales: 
\begin{itemize}
    \item Finito: Debe haber una cantidad finita de elementos.
    \item Composicional: El conjunto de elementos atómicos deben ser fáciles de implementar y componer.
    \item Posicional: La posición de cada dígito determina en qué proporción modifica su valor a la magnitud total del número.
  \end{itemize}
Algunos de los sistemas de representación más utilizados son: binario, octal, decimal y hexadecimal.

\subsection*{Bases}
Una base nos indica la cantidad de símbolos que podemos utilizar para poder representar determinada magnitud.
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c|}
    \hline
    \textbf{Base} & \textbf{Símbolos disponibles}  \\[0.1cm]
    \hline\hline
    2 (binario) & 0, 1 \\
    8 (octal) & 0, 1, 2, 3, 4, 5, 6, 7 \\
    10 (decimal) & 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 \\
    16 (hexadecimal) & 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F \\
    \hline
    \end{tabular}
    \caption{Bases más utilizadas}
    \label{tab:bases}
\end{table}

La tabla anterior representa los símbolos disponibles para las bases 2, 8, 10 y 16.\\


Consideremos por un momento que estamos en binario; ¿sería correcto que 1 + 1 = 2? ¡No! Porque 2 no es un símbolo válido en base 2.\\

Para indicar la base en la que está escrito un número, se coloca la base entre paréntesis en la esquina inferior derecha.\\

\(1024_{(10)}\): 1024 representado en base 10 (decimal)

    
\subsection*{Digítos/Bits}
Sea \( n \in \mathbb{Z} \), cuando decimos que tenemos n bits es lo mismo que decir que tenemos n dígitos.
\\
\begin{itemize}
\item 0001: Representa el número 1 en binario, en 4 bits/dígitos.
\item 0010: Representa el número 2 en binario, en 4 bits/dígitos.
\end{itemize}

\subsection*{Teorema de división}
Es una manera de poder realizar un cambio de base de un número decimal a otra base. La representación en la otra base es el resto visto desde abajo hacia arriba.

\[a = k \ast d + r \ con \ 0 \le r < \longitud{d}\] donde:
\begin{itemize}
    \item k = cociente
    \item d = divisor.
    \item r = resto de la división de a por d.
  \end{itemize}

Pasaje del número \(128_{(10)}\) a \(128_{(2)}\) en 8 bits

\[128 = 64 \ast 2 + 0\]
\[64 = 32 \ast 2 + 0\]
\[32 = 16 \ast 2 + 0\]
\[16 = 8 \ast 2 + 0\]
\[8 = 4 \ast 2 + 0\]
\[4 = 2 \ast 2 + 0\]
\[2 = 1 \ast 2 + 0\]
\[1 = 0 \ast 2 + 1\]

Luego, \(128_{(2)}\) = 1000 0000

\subsection*{Bit más significativo / menos significativo}
El bit más significativo en un número es el que se encuentra a la izquierda, mientras que el menos significativo es el que se encuentra a la derecha.
\[\textcolor{blue}{\textbf{1}}000 000\textcolor{blue}{\textbf{0}}_{(2)}\]


\subsection*{Tipos numéricos}
Representemos números naturales y enteros a partir de la representación en base 2 (binario) \\

\textbf{Sin signo}: Representa únicamente números positivos. No se pueden utilizar los símbolos de resta (\textbf{-}) ni tampoco coma (\textbf{,})
\[1_{(10)} = 01_{(2)}\]
\[128_{(10)} = 1000 0000_{(2)}\]

\textbf{Signo + Magnitud}: Nos permite representar números negativos en binario. \\ El bit más significativo indica el signo
\begin{itemize}
    \item 0: número positivo
    \item 1: número negativo.
\end{itemize}

\[18_{(10)} = \textcolor{blue}{\textbf{0}}0010010_{(2)}\]
\[-18_{(10)} = \textcolor{blue}{\textbf{1}}0010010_{(2)}\]

Representar números en S+M suele traer problemas porque el 0 puede representarse de dos maneras
\[+0_{(10)} = \textcolor{blue}{\textbf{0}}0000000_{(2)}\]
\[-0_{(10)} = \textcolor{blue}{\textbf{1}}0000000_{(2)}\]

Para solucionar este problema, las CPU utilizan la notación Complemento a 2 \((C_{2})\) \\

\textbf{Exceso m}: Sea \( m \in \mathbb{Z} \), decimos que un número n está con exceso \(m\) unidades cuando \(m>0\) 
\[n_{0}=n+m\]
\[n=1 \land m=10 \implica n_{0}=-9 \]
Nota: \(n_{0}\) indica el valor original de \(n\)  antes de ser excedido \(m\) unidades.  \\

\textbf{Complemento a 2}: Los positivos se representan igual. \\ 
El bit más significativo indica el signo, facilitando saber si el número es positivo o negativo.
Cosas a tener en cuenta
\begin{itemize}
    \item \textbf{Rango}: \( -2^{n-1} \ hasta \ 2^{n-1}-1 \)
    \item \textbf{Cantidad} de representaciones del cero: Una sola
    \item \textbf{Negación}: Invierto el número en representación binaria positiva y le sumo uno.
    \begin{itemize}
        \item \(-2_{(2)} = inv(010) + 1\)
        \item \(-2_{(2)} = 101 + 1\)
        \item \(-2_{(2)} = 110\)
    \end{itemize}
    \item \textbf{Extender número a más bits}: Se rellena a la izquierda con el valor del bit del signo.
    \item \textbf{Regla de Desbordamiento}: Si se suman dos números con el mismo signo, solo se produce desbordamiento cuando el resultado tiene signo opuesto.
\end{itemize}

\subsection*{Overflow / Desbordamiento}
Hablamos de overflow/desbordamiento cuando 
\begin{itemize}
    \item\label{item:overflow1} El número a representar en una base dada, excede la cantidad de bits que tenemos disponibles.
    \item\label{item:overflow2} Si estamos en notación \(C_{2}\) al sumar dos números cambia el signo.
\end{itemize} 


\subsection*{Acarreo / Carry}
Ocurre cuando realizamos una suma de números binarios y el resultado tiene más bits que los números originales que estamos sumando

\subsection*{Suma entre números binarios}
Se hace exactamente igual que una suma común y corriente. \\
Es importante prestar atención a la cantidad de dígitos que nos piden para representarlo, y en caso de estar en \(C_{2}\) que el signo no cambie.\\ 
\\
Hagamos sumas en \(C_{2}\) (sin límite de bits)

\begin{align*}
    &\begin{array}{@{} r@{}}
      0010 = 2 \\
    + 1001 = -7\\
    \hline
    \ 1011 = -5
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0101 = 5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}0011 = 3
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1011 = -5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}1001 = -7
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0111 = 7 \\
    + 0111 = 7\\
    \hline
    \textcolor{red}{\textbf{1}}110 = \text{Overflow}
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1010 = -6 \\
    + 1100 = -4 \\
    \hline
    \textcolor{blue}{\textbf{1}}\textcolor{red}{\textbf{0}}110 = \text{Overflow}
    \end{array}
    \end{align*}

Nota: El color azul indica el carry; El rojo indica qué es lo que produce overflow (cambio de signo).
\\
\\
Hagamos sumas en \(C_{2}\) (límite de bits: 4)

\begin{align*}
    &\begin{array}{@{} r@{}}
      0010 = 2 \\
    + 1001 = -7\\
    \hline
    \ 1011 = -5
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0101 = 5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}0011 = Overflow
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1011 = -5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}1001 = Overflow
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0111 = 7 \\
    + 0111 = 7\\
    \hline
    \textcolor{red}{\textbf{1}}110 = \text{Overflow}
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1010 = -6 \\
    + 1100 = -4 \\
    \hline
    \textcolor{blue}{\textbf{1}}\textcolor{red}{\textbf{0}}110 = \text{Overflow}
    \end{array}
    \end{align*}

Nota: Al tener un límite de 4 bits, en las sumas que tenemos carry terminamos teniendo overflow.

\subsection*{Rango de valores representables en n bits}
Sean \( n, m \in \mathbb{Z} \) decimos que el rango de representación en base \(n\) y \(m\) bits acepta el rango de valores de: 
\(
\left[ -n^m, n^m - 1 \right]
\)

¿Es posible representar el 1024 en binario y 4 bits? No.
\begin{itemize}
    \item \(2^4\) = 16 \(\implies [-16, 15]\)
    \item Pero, 1024 \(\notin [-16, 15]\)
    \item Por lo tanto, 1024 no es representable en 4 bits.
\end{itemize} 

\subsection*{Pasar número binario a decimal}
1. Si tenemos el mismo número todo el tiempo podemos usar la serie geométrica \\

¿Qué número decimal representa el número \(1111111111_{(2)}\)?
\[
\begin{array}{l}
\sum_{i=0}^{j-1} 1 \cdot n^i = \begin{array}{@{} r @{}}
    q^{n+1} - 1 \\
    \hline
    q-1
 \end{array}
\end{array}
Luego, 
\]
\[
\begin{array}{l}
\sum_{i=0}^{9} 1 \cdot 2^i = \begin{array}{@{} r @{}}
    2^{10} - 1 = 1023 \\
 \end{array}
\end{array}
\]

2. Si no tenemos el mismo número todo el tiempo podemos multiplicar cada dígito por la base donde el exponente es la posición del bit. \\

\(10_{(2)} = 1 \ast 2^{1} + 0 \ast 2^{0} = 2_{(10)} \)

\subsection*{Extender un número de n bits a m bits}
Sea \( n, m \in \mathbb{Z} \) donde \(n\) es la cantidad de bits inicial y \(m\) es la cantidad a la que se quiere extender.
\[n = 3 \land m = 8\]

\begin{itemize}
    \item Signo + Magnitud y exceso m: Se extiende con 0's luego del signo.
    \begin{itemize}
        \item En 3 bits, -2 = 110
        \item En 8 bits, -2 = \textcolor{blue}{\textbf{1}}\textcolor{cyan}{\textbf{00000}}10
    \end{itemize}
    \item Complemento 2 (\(C_{2}\)): Se extiende con el bit más significativo.
    \begin{itemize}
        \item En 3 bits, -2 = 110
        \item En 8 bits, -2 = \textcolor{blue}{\textbf{1}}\textcolor{cyan}{\textbf{11111}}10
    \end{itemize}
\end{itemize} 

\subsection*{Cambios de base} 
Sea \( n, m \in \mathbb{Z} \) dos bases distintas, para pasar de base \(n\) a base \(m\) se debe realizar el siguiente proceso

\begin{itemize}
    \item Pasar el número a base decimal.
    \item Aplicar el teorema de división utilizando la base deseada.
\end{itemize}

Encontremos en base 5, el número que corresponde a \(17_{(8)}\):
\begin{itemize}
    \item  \( 17_{(8)} = 1 \ast 8^{1} + 7 \ast 8^{0} = 15_{(10)} \)
    \item Usando ahora el teorema de división
    \begin{itemize}
    \item  \( 15 = 3 \ast 5 + 0 \)
    \item  \( 3 = 0 \ast 5 + 3 \)
    \item Luego, \( 30_{(5)} \)
    \end{itemize} 
    \item Por lo tanto, \( 17_{(8)} = 30_{(5)} \)
\end{itemize} 

\section{Desplazamientos}
Utilizamos los desplazamientos para poder mover los bits. Cada casillero representa los bits.
\begin{itemize}
    \item Desplazamiento hacia la izquierda: Se desplazan los bits del dato tantas posiciones como se indiquen a la izquierda. \\
     \(variable << cantidad\)\\ \begin{minipage}[b]{0.32\textwidth}
        \includegraphics[width=\linewidth]{assets/desplazamiento_izquierda.png}
        \label{fig:desplazamiento_izquierda}
    \end{minipage}

    \item Desplazamiento lógico hacia la derecha: Se aplica desplazando los bits del dato tantas posiciones como se indiquen a la derecha. \\
    \(variable >>_{l} cantidad\)\\ \begin{minipage}[b]{0.3\textwidth}
            \includegraphics[width=\linewidth]{assets/desplazamiento_logico_der.png}
            \label{fig:desplazamiento_der_logico}
        \end{minipage}

    \item Desplazamiento aritmético hacia la derecha: Se aplica desplazando los bits del dato tantas posiciones como se indiquen a la derecha, pero copiando el valor del bit más significativo. \\
     \(variable >>_{a} cantidad\)\\ \begin{minipage}[b]{0.33\textwidth}
            \includegraphics[width=\linewidth]{assets/desplazamiento_aritmetico_der.png}
            \label{fig:desplazamiento_der_aritmetico}
        \end{minipage}

\end{itemize} 

\newpage
\section{Operaciones lógicas}
\begin{itemize}
\item OR (+): (1, 0), (0, 1), (1, 1) = 1
\item AND \((\ast)\): (1, 1) = 1
\item XOR \((\oplus)\): (1, 0), (0, 1) = 1
\end{itemize} 

\section{Circuitos combinatorios}
\subsection*{Negación}
Sea \(p\) una variable proposicional, el opuesto de \(p\) lo escribimos como \(\bar{p}\).
\[ p = 1 \iff \bar{p} = 0 \]

\subsection*{Propiedades para operaciones lógicas} 
\label{subsec:PPOL}
\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/propiedades_operaciones_logicas.png}
    \label{fig:propiedades_operaciones_logicas}
\end{minipage}
\subsection*{Operaciones booleanas}
Se resuelven utilizando las \hyperref[subsec:PPOL]{propiedades para operaciones lógicas}
\[Verifique \ si \ son \ equivalentes \ (X + \bar{Y} = \overline{(\bar{X} \ast Y)} \ast Z + X \ast \bar{Z} + \overline{(Y+Z)})\]
\begin{itemize}
    \item  \(\overline{\bar{X} \ast Y} \ast Z + X \ast \bar{Z} + \textcolor{blue}{(\bar{Y} \ast \bar{Z})} \implies De \ Morgan\) 
    \item  \(\textcolor{blue}{(X + \bar{Y})} \ast Z + \textcolor{purple}{X \ast \bar{Z}} + \textcolor{purple}{(\bar{Y} \ast \bar{Z})}\implies De \ Morgan \ \land \ Distributiva \) 
    \item  \((X + \bar{Y}) \ast Z + \bar{Z} \ast (X + \bar{Y})\)
    \item  \((X + \bar{Y}) \ast \textcolor{red}{(Z + \bar{Z})} \implies Inverso\) 
    \item  \((X + \bar{Y}) \ast \textcolor{cyan}{1} \implies Identidad \) 
    \item  \((X + \bar{Y})\)
\end{itemize}
Nota: También se pueden probar equivalencias utilizando \hyperref[subsec:TDV]{tablas de verdad}
\subsection*{Funciones booleanas}
\begin{itemize}
    \item AND = A \(\ast \) B
    \item OR = A + B
    \item NOT = \(\bar{A}\)
    \end{itemize} 


\newpage
\subsection*{Tablas de verdad} \label{subsec:TDV}
Nos permiten observar todas las salidas para todas las combinaciones de entradas dada una función. 

Veamos un ejemplo con una función F: 
\[Sea \ F = X + \bar{Y}\]
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c | c|}
    \hline
    \textbf{X} & \textbf{Y} & \textbf{F}  \\[0.1cm]
    \hline\hline
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \hline
    \end{tabular}
    \label{tab:x_y}
\end{table}

Protip: El símbolo de + indica OR porque 1 + 0 = 1 mientras que el símbolo AND indica * porque 1 * 0 = 0 

\subsection*{Compuertas}
Son modelos idealizados de dispositivos electrónicos que realizan operaciones booleanas.\\
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/compuertas.png}
    \label{fig:compuertas}
\end{minipage}\]
Nota: XOR = \(\oplus\)
\subsection*{Compuertas Universales}
Nos permiten obtener otros operadores.
\begin{itemize}
    \item NAND = \(\overline{A \land B}\)
    \item NOR = \(\overline{A \lor B}\)
    \item XNOR = \(\overline{A \oplus B}\) = Si son iguales es V
\end{itemize} 

\subsection*{Compuertas en SystemVerilog}
\begin{itemize}
    \item A AND B \((A \ast B)\) = (assign O = A \& B)
    \item A OR B \((A + B)\)= \(assign \ A \ | \ B\)
    \item A XOR B = \(assign \ A \ \land \ B\)
    \item NOT A \((\bar{a}\)) = \((\thicksim A)\)
\end{itemize} 

\subsection*{Entradas / Salidas de un circuito}
Se representan con flechas. En SystemVerilog se llaman input y output.\\
\begin{minipage}[b]{0.5\textwidth}
    \includegraphics[width=\linewidth]{assets/input_output_sys_verilog.png}
    \label{fig:input_output_sys_verilog}
\end{minipage}

Nota: En las ALU no son funcionalmente iguales ni las entradas ni las salidas.

\subsection*{Mecanismo de Traducción fórmula a circuito}
Llamaremos \(\phi\) a una fórmula proposicional cualquiera
\begin{itemize}
    \item 1. Solo consideramos de la función F, las filas verdaderas.
    \item 2. Cada fila verdadera tendrá su índice, y en ese índice estarán los valores de cada variable proposicional. Representamos a esa fila verdadera como \(t_{i}\)
    \item 3. Realizamos la conjunción de todas las variables de ese \(t_{i}\)
    \item 4. Realizamos la disyunción de todas las conjunciones de \(t_{i}\)
\end{itemize} 

Un ejemplo: 
\[Sea \ F = X + \bar{Y}\]
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c | c|}
    \hline
    \textbf{X} & \textbf{Y} & \textbf{F}  \\[0.1cm]
    \hline\hline
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \hline
    \end{tabular}
    \label{tab:traduccion}
\end{table}
\begin{itemize}
    \item F es solamente verdadera en la primera, segunda y tercer fila por lo tanto tenemos \(t_{1} \ t_{2} \ y \ t_{3}\)
    \item Por cada fila, hacemos la conjunción de los valores
    \begin{itemize}
        \item \(x_{1} \land x_{2}\)
        \item \(\bar{x_{1}} \land x_{2}\)
        \item \(\bar{x_{1}} \land \bar{x_{2}}\)
    \end{itemize}
    \item Realizamos la disyunción de todos los \(t_{i}\)
    \begin{itemize}
        \item \((x_{1} \land x_{2}) \lor (\bar{x_{1}} \land x_{2}) \lor (\bar{x_{1}} \land \bar{x_{2}}) \)
    \end{itemize}
    \item El resultado nos da \(\phi'\) que es una suma de productos y nos permite traducir fácilmente a un circuito combinatorio \(\implies\) BUSCAR EJEMPLO
\end{itemize} 

\subsection*{Timing}
En un circuito combinatorio el tiempo que tarda la salida en estabilizarse depende de la cantidad de capas de compuertas (latencia). Para enfrentar el problema usamos secuenciales.

\end{document}