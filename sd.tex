\documentclass[10pt,a4paper]{article}
\usepackage{blindtext}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{hyperref}
\usepackage{amssymb}
\input{AEDmacros}

\title{Sistemas Digitales}
\author{Tomás Agustín Hernández}
\date{}

\begin{document}
\maketitle


\begin{figure}[b]
    \centering
    \begin{tikzpicture}[remember picture,overlay]
        \node[anchor=south east, inner sep=0pt, xshift=-1cm, yshift=2cm] at (current page.south east) {
            \begin{minipage}[b]{0.5\textwidth}
                \includegraphics[width=\linewidth]{logo_uba.jpg}
                \label{fig:bottom}
            \end{minipage}
        };
    \end{tikzpicture}
\end{figure}

\newpage

\section{Introducción a los sistemas de representación}
\subsection*{Magnitud}
Llamamos magnitud al tamaño de algo, dicho en una medida específica. 
Es representada a través de un sistema que cumple 3 conceptos fundamentales: 
\begin{itemize}
    \item Finito: Debe haber una cantidad finita de elementos.
    \item Composicional: El conjunto de elementos atómicos deben ser fáciles de implementar y componer.
    \item Posicional: La posición de cada dígito determina en qué proporción modifica su valor a la magnitud total del número.
  \end{itemize}
Algunos de los sistemas de representación más utilizados son: binario, octal, decimal y hexadecimal.

\subsection*{Bases}
Una base nos indica la cantidad de símbolos que podemos utilizar para poder representar determinada magnitud.
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c|}
    \hline
    \textbf{Base} & \textbf{Símbolos disponibles}  \\[0.1cm]
    \hline\hline
    2 (binario) & 0, 1 \\
    8 (octal) & 0, 1, 2, 3, 4, 5, 6, 7 \\
    10 (decimal) & 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 \\
    16 (hexadecimal) & 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F \\
    \hline
    \end{tabular}
    \caption{Bases más utilizadas}
    \label{tab:bases}
\end{table}

La tabla anterior representa los símbolos disponibles para las bases 2, 8, 10 y 16.\\


Consideremos por un momento que estamos en binario; ¿sería correcto que 1 + 1 = 2? ¡No! Porque 2 no es un símbolo válido en base 2.\\

Para indicar la base en la que está escrito un número, se coloca la base entre paréntesis en la esquina inferior derecha.\\

\(1024_{(10)}\): 1024 representado en base 10 (decimal)

    
\subsection*{Digítos/Bits}
Sea \( n \in \mathbb{Z} \), cuando decimos que tenemos n bits es lo mismo que decir que tenemos n dígitos.
\\
\begin{itemize}
\item 0001: Representa el número 1 en binario, en 4 bits/dígitos.
\item 0010: Representa el número 2 en binario, en 4 bits/dígitos.
\end{itemize}

\subsection*{Teorema de división}
Es una manera de poder realizar un cambio de base de un número decimal a otra base. La representación en la otra base es el resto visto desde abajo hacia arriba.

\[a = k \ast d + r \ con \ 0 \le r < \longitud{d}\] donde:
\begin{itemize}
    \item k = cociente
    \item d = divisor.
    \item r = resto de la división de a por d.
  \end{itemize}

Pasaje del número \(128_{(10)}\) a \(128_{(2)}\) en 8 bits

\[128 = 64 \ast 2 + 0\]
\[64 = 32 \ast 2 + 0\]
\[32 = 16 \ast 2 + 0\]
\[16 = 8 \ast 2 + 0\]
\[8 = 4 \ast 2 + 0\]
\[4 = 2 \ast 2 + 0\]
\[2 = 1 \ast 2 + 0\]
\[1 = 0 \ast 2 + 1\]

Luego, \(128_{(2)}\) = 1000 0000

\subsection*{Bit más significativo / menos significativo}
El bit más significativo en un número es el que se encuentra a la izquierda, mientras que el menos significativo es el que se encuentra a la derecha.
\[\textcolor{blue}{\textbf{1}}000 000\textcolor{blue}{\textbf{0}}_{(2)}\]


\subsection*{Tipos numéricos}
Representemos números naturales y enteros a partir de la representación en base 2 (binario) \\

\textbf{Sin signo}: Representa únicamente números positivos. No se pueden utilizar los símbolos de resta (\textbf{-}) ni tampoco coma (\textbf{,})
\[1_{(10)} = 01_{(2)}\]
\[128_{(10)} = 1000 0000_{(2)}\]

\textbf{Signo + Magnitud}: Nos permite representar números negativos en binario. \\ El bit más significativo indica el signo
\begin{itemize}
    \item 0: número positivo
    \item 1: número negativo.
\end{itemize}

\[18_{(10)} = \textcolor{blue}{\textbf{0}}0010010_{(2)}\]
\[-18_{(10)} = \textcolor{blue}{\textbf{1}}0010010_{(2)}\]

Representar números en S+M suele traer problemas porque el 0 puede representarse de dos maneras
\[+0_{(10)} = \textcolor{blue}{\textbf{0}}0000000_{(2)}\]
\[-0_{(10)} = \textcolor{blue}{\textbf{1}}0000000_{(2)}\]

Para solucionar este problema, las CPU utilizan la notación Complemento a 2 \((C_{2})\) \\

\textbf{Exceso m}: Sea \( m \in \mathbb{Z} \), decimos que un número n está con exceso \(m\) unidades cuando \(m>0\) 
\[n_{0}=n+m\]
\[n=1 \land m=10 \implica n_{0}=-9 \]
Nota: \(n_{0}\) indica el valor original de \(n\)  antes de ser excedido \(m\) unidades.  \\

\textbf{Complemento a 2}: Los positivos se representan igual. \\ 
El bit más significativo indica el signo, facilitando saber si el número es positivo o negativo.
Cosas a tener en cuenta
\begin{itemize}
    \item \textbf{Rango}: \( -2^{n-1} \ hasta \ 2^{n-1}-1 \)
    \item \textbf{Cantidad} de representaciones del cero: Una sola
    \item \textbf{Negación}: Invierto el número en representación binaria positiva y le sumo uno.
    \begin{itemize}
        \item \(-2_{(2)} = inv(010) + 1\)
        \item \(-2_{(2)} = 101 + 1\)
        \item \(-2_{(2)} = 110\)
    \end{itemize}
    \item \textbf{Extender número a más bits}: Se rellena a la izquierda con el valor del bit del signo.
    \item \textbf{Regla de Desbordamiento}: Si se suman dos números con el mismo signo, solo se produce desbordamiento cuando el resultado tiene signo opuesto.
\end{itemize}

\subsection*{Overflow / Desbordamiento}
Hablamos de overflow/desbordamiento cuando 
\begin{itemize}
    \item\label{item:overflow1} El número a representar en una base dada, excede la cantidad de bits que tenemos disponibles.
    \item\label{item:overflow2} Si estamos en notación \(C_{2}\) al sumar dos números cambia el signo.
\end{itemize} 


\subsection*{Acarreo / Carry}
Ocurre cuando realizamos una suma de números binarios y el resultado tiene más bits que los números originales que estamos sumando

\subsection*{Borrow}
Borrow \(\equiv\) Préstamo. \\
Se produce cuando el sustraendo (denominador) es mayor que el minuendo (numerador) por lo tanto se debe pedir.

\begin{lstlisting}
      0111
    - 1000
      ====
      1011

      El primer cero le pide al uno de su derecha.
\end{lstlisting}

\subsection*{Suma entre números binarios}
Se hace exactamente igual que una suma común y corriente. \\
Es importante prestar atención a la cantidad de dígitos que nos piden para representarlo, y en caso de estar en \(C_{2}\) que el signo no cambie.\\ 
\\
Hagamos sumas en \(C_{2}\) (sin límite de bits)

\begin{align*}
    &\begin{array}{@{} r@{}}
      0010 = 2 \\
    + 1001 = -7\\
    \hline
    \ 1011 = -5
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0101 = 5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}0011 = 3
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1011 = -5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}1001 = -7
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0111 = 7 \\
    + 0111 = 7\\
    \hline
    \textcolor{red}{\textbf{1}}110 = \text{Overflow}
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1010 = -6 \\
    + 1100 = -4 \\
    \hline
    \textcolor{blue}{\textbf{1}}\textcolor{red}{\textbf{0}}110 = \text{Overflow}
    \end{array}
    \end{align*}

Nota: El color azul indica el carry; El rojo indica qué es lo que produce overflow (cambio de signo).
\\
\\
Hagamos sumas en \(C_{2}\) (límite de bits: 4)

\begin{align*}
    &\begin{array}{@{} r@{}}
      0010 = 2 \\
    + 1001 = -7\\
    \hline
    \ 1011 = -5
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0101 = 5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}0011 = Overflow
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1011 = -5 \\
    + 1110 = -2 \\
    \hline
    \textcolor{blue}{\textbf{1}}1001 = Overflow
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       0111 = 7 \\
    + 0111 = 7\\
    \hline
    \textcolor{red}{\textbf{1}}110 = \text{Overflow}
    \end{array}
    &&
    \begin{array}{@{} r @{}}
       1010 = -6 \\
    + 1100 = -4 \\
    \hline
    \textcolor{blue}{\textbf{1}}\textcolor{red}{\textbf{0}}110 = \text{Overflow}
    \end{array}
    \end{align*}

Nota: Al tener un límite de 4 bits, en las sumas que tenemos carry terminamos teniendo overflow.
\subsection*{Resta entre numeros binarios}
La resta entre números binarios debe realizarse en \(C_{2}\)

La idea es que A - B \(\equiv\) A + (INV(B) + 1) 
\subsection*{¿Cuando hay overflow, carry o borrow?}
\begin{itemize}
    \item POS + POS = NEG
    \item NEG + NEG = POS
    \item POS - NEG = NEG
    \item NEG - POS = POS 
\end{itemize}
\begin{lstlisting}
      0101
    + 0110
      ====
      1011  - OV: si - C: no

      1000
    + 1100
      ====
      10100 - OV: si - Carry si

      1010
    - 0100
      ====
      1000 - OV: si - Borrow no

      0100
    - 1000
      ====
      1000 - OV: si - Borrow si
\end{lstlisting}
\subsection*{Rango de valores representables en n bits}
Sean \( n, m \in \mathbb{Z} \) decimos que el rango de representación en base \(n\) y \(m\) bits acepta el rango de valores de: 
\(
\left[ -n^m, n^m - 1 \right]
\)

¿Es posible representar el 1024 en binario y 4 bits? No.
\begin{itemize}
    \item \(2^4\) = 16 \(\implies [-16, 15]\)
    \item Pero, 1024 \(\notin [-16, 15]\)
    \item Por lo tanto, 1024 no es representable en 4 bits.
\end{itemize} 

\subsection*{Pasar número binario a decimal}
1. Si tenemos el mismo número todo el tiempo podemos usar la serie geométrica \\

¿Qué número decimal representa el número \(1111111111_{(2)}\)?
\[
\begin{array}{l}
\sum_{i=0}^{j-1} 1 \cdot n^i = \begin{array}{@{} r @{}}
    q^{n+1} - 1 \\
    \hline
    q-1
 \end{array}
\end{array}
Luego, 
\]
\[
\begin{array}{l}
\sum_{i=0}^{9} 1 \cdot 2^i = \begin{array}{@{} r @{}}
    2^{10} - 1 = 1023 \\
 \end{array}
\end{array}
\]

2. Si no tenemos el mismo número todo el tiempo podemos multiplicar cada dígito por la base donde el exponente es la posición del bit. \\

\(10_{(2)} = 1 \ast 2^{1} + 0 \ast 2^{0} = 2_{(10)} \)

\subsection*{Extender un número de n bits a m bits}
Sea \( n, m \in \mathbb{Z} \) donde \(n\) es la cantidad de bits inicial y \(m\) es la cantidad a la que se quiere extender.
\[n = 3 \land m = 8\]

\begin{itemize}
    \item Signo + Magnitud y exceso m: Se extiende con 0's luego del signo.
    \begin{itemize}
        \item En 3 bits, -2 = 110
        \item En 8 bits, -2 = \textcolor{blue}{\textbf{1}}\textcolor{cyan}{\textbf{00000}}10
    \end{itemize}
    \item Complemento 2 (\(C_{2}\)): Se extiende con el bit más significativo.
    \begin{itemize}
        \item En 3 bits, -2 = 110
        \item En 8 bits, -2 = \textcolor{blue}{\textbf{1}}\textcolor{cyan}{\textbf{11111}}10
    \end{itemize}
\end{itemize} 

\subsection*{Cambios de base} 
Sea \( n, m \in \mathbb{Z} \) dos bases distintas, para pasar de base \(n\) a base \(m\) se debe realizar el siguiente proceso

\begin{itemize}
    \item Pasar el número a base decimal.
    \item Aplicar el teorema de división utilizando la base deseada.
\end{itemize}

Encontremos en base 5, el número que corresponde a \(17_{(8)}\):
\begin{itemize}
    \item  \( 17_{(8)} = 1 \ast 8^{1} + 7 \ast 8^{0} = 15_{(10)} \)
    \item Usando ahora el teorema de división
    \begin{itemize}
    \item  \( 15 = 3 \ast 5 + 0 \)
    \item  \( 3 = 0 \ast 5 + 3 \)
    \item Luego, \( 30_{(5)} \)
    \end{itemize} 
    \item Por lo tanto, \( 17_{(8)} = 30_{(5)} \)
\end{itemize} 

\section{Desplazamientos}
Utilizamos los desplazamientos para poder mover los bits. Cada casillero representa los bits.
\begin{itemize}
    \item Desplazamiento hacia la izquierda: Se desplazan los bits del dato tantas posiciones como se indiquen a la izquierda. \\
     \(variable << cantidad\)\\ \begin{minipage}[b]{0.32\textwidth}
        \includegraphics[width=\linewidth]{assets/desplazamiento_izquierda.png}
        \label{fig:desplazamiento_izquierda}
    \end{minipage}

    \item Desplazamiento lógico hacia la derecha: Se aplica desplazando los bits del dato tantas posiciones como se indiquen a la derecha. \\
    \(variable >>_{l} cantidad\)\\ \begin{minipage}[b]{0.3\textwidth}
            \includegraphics[width=\linewidth]{assets/desplazamiento_logico_der.png}
            \label{fig:desplazamiento_der_logico}
        \end{minipage}

    \item Desplazamiento aritmético hacia la derecha: Se aplica desplazando los bits del dato tantas posiciones como se indiquen a la derecha, pero copiando el valor del bit más significativo. \\
     \(variable >>_{a} cantidad\)\\ \begin{minipage}[b]{0.33\textwidth}
            \includegraphics[width=\linewidth]{assets/desplazamiento_aritmetico_der.png}
            \label{fig:desplazamiento_der_aritmetico}
        \end{minipage}

\end{itemize} 

\newpage
\section{Operaciones lógicas}
\begin{itemize}
\item OR (+): (1, 0), (0, 1), (1, 1) = 1
\item AND \((\ast)\): (1, 1) = 1
\item XOR \((\oplus)\): (1, 0), (0, 1) = 1
\end{itemize} 

\section{Circuitos combinatorios}
\subsection*{Negación}
Sea \(p\) una variable proposicional, el opuesto de \(p\) lo escribimos como \(\bar{p}\).
\[ p = 1 \iff \bar{p} = 0 \]

\subsection*{Propiedades para operaciones lógicas} 
\label{subsec:PPOL}
\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/propiedades_operaciones_logicas.png}
    \label{fig:propiedades_operaciones_logicas}
\end{minipage}
\subsection*{Operaciones booleanas}
Se resuelven utilizando las \hyperref[subsec:PPOL]{propiedades para operaciones lógicas}
\[Verifique \ si \ son \ equivalentes \ (X + \bar{Y} = \overline{(\bar{X} \ast Y)} \ast Z + X \ast \bar{Z} + \overline{(Y+Z)})\]
\begin{itemize}
    \item  \(\overline{\bar{X} \ast Y} \ast Z + X \ast \bar{Z} + \textcolor{blue}{(\bar{Y} \ast \bar{Z})} \implies De \ Morgan\) 
    \item  \(\textcolor{blue}{(X + \bar{Y})} \ast Z + \textcolor{purple}{X \ast \bar{Z}} + \textcolor{purple}{(\bar{Y} \ast \bar{Z})}\implies De \ Morgan \ \land \ Distributiva \) 
    \item  \((X + \bar{Y}) \ast Z + \bar{Z} \ast (X + \bar{Y})\)
    \item  \((X + \bar{Y}) \ast \textcolor{red}{(Z + \bar{Z})} \implies Inverso\) 
    \item  \((X + \bar{Y}) \ast \textcolor{cyan}{1} \implies Identidad \) 
    \item  \((X + \bar{Y})\)
\end{itemize}
Nota: También se pueden probar equivalencias utilizando \hyperref[subsec:TDV]{tablas de verdad}
\subsection*{Funciones booleanas}
\begin{itemize}
    \item AND = A \(\ast \) B
    \item OR = A + B
    \item NOT = \(\bar{A}\)
    \end{itemize} 


\subsection*{Tablas de verdad} \label{subsec:TDV}
Nos permiten observar todas las salidas para todas las combinaciones de entradas dada una función. 

Veamos un ejemplo con una función F: 
\[Sea \ F = X + \bar{Y}\]
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c | c|}
    \hline
    \textbf{X} & \textbf{Y} & \textbf{F}  \\[0.1cm]
    \hline\hline
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \hline
    \end{tabular}
    \label{tab:x_y}
\end{table}

Protip: El símbolo de + indica OR porque 1 + 0 = 1 mientras que el símbolo AND indica * porque 1 * 0 = 0 

\subsection*{Compuertas}
Son modelos idealizados de dispositivos electrónicos que realizan operaciones booleanas.\\
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/compuertas.png}
    \label{fig:compuertas}
\end{minipage}\]

Nota: XOR = \(\oplus\) 
Nota: Estas compuertas devuelven una única salida. Imaginemos que tenemos solamente NAND ¿Como podemos conseguir una AND? Aplicando una NAND luego de la otra.  \href{http://hyperphysics.phy-astr.gsu.edu/hbasees/Electronic/nand.html}{Enlace a Electronic HyperPhysics}
\subsection*{Compuertas Universales}
Nos permiten obtener otros operadores.
\begin{itemize}
    \item NAND = \(\overline{A \land B}\)
    \item NOR = \(\overline{A \lor B}\)
    \item XNOR = \(\overline{A \oplus B}\) = Si son iguales es V
\end{itemize} 

\subsection*{Compuertas en SystemVerilog}
\begin{itemize}
    \item A AND B \((A \ast B)\) = (assign O = A \& B)
    \item A OR B \((A + B)\)= \(assign \ A \ | \ B\)
    \item A XOR B = \(assign \ A \ \land \ B\)
    \item NOT A \((\bar{a}\)) = \((\thicksim A)\)
\end{itemize} 

\subsection*{Caja Blanca / Caja Negra en Circuitos}
\begin{figure}[h]
    \begin{subfigure}{0.5\textwidth}
        \centering
    \includegraphics[width=1\linewidth]{assets/caja_blanca.png}
    \caption{Caja Blanca}
    \label{fig:cajaBlanca}
    \end{subfigure}
    %
    \begin{subfigure}{0.6\textwidth}
    \centering
    \includegraphics[width=0.7\linewidth]{assets/caja_negra.png}
    \caption{Caja Negra. 16 indica los bits de entrada \(\&\) salida}
    \label{fig:cajaNegra}
    \end{subfigure}
    \end{figure}
Nota: Ov indica Overflow

\subsection*{Entradas / Salidas de un circuito}
Se representan con flechas. En SystemVerilog se llaman input y output.\\
\begin{minipage}[b]{0.5\textwidth}
    \includegraphics[width=\linewidth]{assets/input_output_sys_verilog.png}
    \label{fig:input_output_sys_verilog}
\end{minipage}

Nota: En las ALU no son funcionalmente iguales ni las entradas ni las salidas.
\subsection*{Entradas y salidas: Datos vs Control}
\begin{itemize}
    \item Datos: Indican lo que tratamos de transformar.
    \begin{itemize}
        \item Entrada: Registro Z y Registro Y.
        \item Salida: El resultado de la operación
    \end{itemize}
    \item Control: Indican como transformamos los datos.
    \begin{itemize}
        \item Entrada: Enviar ADD, Enviar AND, Enviar XOR, ...
        \item Salida: Ov
    \end{itemize}
\end{itemize} 

\subsection*{Mecanismo de Traducción fórmula a circuito}
Llamaremos \(\phi\) a una fórmula proposicional cualquiera
\begin{itemize}
    \item 1. Solo consideramos de la función F, las filas verdaderas.
    \item 2. Cada fila verdadera tendrá su índice, y en ese índice estarán los valores de cada variable proposicional. Representamos a esa fila verdadera como \(t_{i}\)
    \item 3. Realizamos la conjunción de todas las variables de ese \(t_{i}\)
    \item 4. Realizamos la disyunción de todas las conjunciones de \(t_{i}\)
\end{itemize} 

Un ejemplo: 
\[Sea \ F = X + \bar{Y}\]
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c | c|}
    \hline
    \textbf{X} & \textbf{Y} & \textbf{F}  \\[0.1cm]
    \hline\hline
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \hline
    \end{tabular}
    \label{tab:traduccion}
\end{table}
\begin{itemize}
    \item F es solamente verdadera en la primera, segunda y tercer fila por lo tanto tenemos \(t_{1} \ t_{2} \ y \ t_{3}\)
    \item Por cada fila, hacemos la conjunción de los valores
    \begin{itemize}
        \item \(x_{1} \land x_{2}\)
        \item \(\bar{x_{1}} \land x_{2}\)
        \item \(\bar{x_{1}} \land \bar{x_{2}}\)
    \end{itemize}
    \item Realizamos la disyunción de todos los \(t_{i}\)
    \begin{itemize}
        \item \((x_{1} \land x_{2}) \lor (\bar{x_{1}} \land x_{2}) \lor (\bar{x_{1}} \land \bar{x_{2}}) \)
    \end{itemize}
    \item El resultado nos da \(\phi'\) que es una suma de productos y nos permite traducir fácilmente a un circuito combinatorio
\end{itemize} 
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/circuito1.jpg}
    \label{fig:circuito1}
\end{minipage}\]

\subsection*{Carry en circuitos}
El carry debe colocarse en los circuitos en la suma porque en caso de no hacerlo, se nos pierden casos.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/sin_carry.jpg}
    \label{fig:sin_carry}
\end{minipage}\]

Si eliminamos el carry se nos pierde el caso 1 \( + \) 1, por lo tanto lo ideal sería que al hacer una suma nos quede así: 
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/suma_carry.jpg}
    \label{fig:suma_carry}
\end{minipage}\]

Nota: El carry es representado con un AND porque en la tabla de verdad solo da uno cuando A = 1 y B = 1. Luego, la función Sum es un XOR.

\subsection*{Sumadores}
Los sumadores nos sirven para poder realizar operaciones entre bits.
Es importante recalcar que llamamos half-adder a un sumador de 1 bit, donde solamente tiene una entrada A de 1 bit y una entrada B de 1 bit.
Un sumador de 1 bit requiere:
\begin{itemize}
    \item Dos entradas A y B de 1 bit
    \item Una compuerta XOR (para la suma): solo el resultado es 1 o 0
    \item Una compuerta AND (para el carry): si la suma del XOR es 1+1
\end{itemize} 
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/sumador_1_bit.png}
    \label{fig:sumador_1_bit}
\end{minipage}\]

Veamos un ejemplo con un sumador completo de 3 entradas: Si para dos entradas necesitabamos un sumador simple, para 3 entradas necesito 2. Porque es (A+B) y luego res+C
\[\begin{minipage}[b]{1\textwidth}
    \includegraphics[width=\linewidth]{assets/sumador_completo.png}
    \label{fig:sumador_completo}
\end{minipage}\]
Nótese que para considerar si es carry al final de toda la suma o no usamos un or porque nos basta con que uno haya arrojado carry.

\subsection*{Inversor}
\begin{itemize}
    \item Si me mandan INV=1 entonces tengo que invertir los bits.
    \item La manera de hacer esto es utilizando un XOR.
\end{itemize} 
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/inversor_4_bits.png}
    \label{fig:inversor_4_bits}
\end{minipage}\]


\subsection*{Multiplexor}
Está conformado por varias entradas de control y entradas de datos. Existe una única salida.
\begin{itemize}
    \item Entradas de control: se indican de la manera \(c_{n}\)
    \item Entradas de datos: se indican de la manera \(e_{n}\)
    \item Ojo: Antes de prender cualquier entrada de control, hay que asegurarse que entrada de datos esté puesta en el que valor que queremos
\end{itemize} 
Te ayuda a ahorrar recursos, pero todas las acciones tardan mucho más tiempo porque solo se ejecuta una a la vez. \\
Nos garantiza que la información solo se envía por un único canal. \\
\\
Para poder calcular la cantidad de entradas de control \(c_{n}\) que necesito para una cantidad m de entradas de datos \(e_{m}\) hago el siguiente cálculo: m \(<\) \(2^{l}\) hasta que me pase por primera vez.
\begin{itemize}
    \item Entradas de datos: 30.
    \item Entradas de control: Necesito 5 entradas de control porque \(2^{5}\) es 32.
\end{itemize} 
Cada entrada de control tiene un índice que podemos decirle individuo, por ejemplo, si tengo \(2^{l}\) entradas tengo 32 posibles combinaciones.
\begin{itemize}
    \item Si tengo 00010 significa que la persona que está hablando la persona 2.
\end{itemize}

En los Multiplexores existen difurcaciones, que cuando llegamos a una de ellas se nos desvía el camino enviándonos a una compuerta. Si en algún momento se llega a un valor 0, entonces decimos que el camino ya finalizó.\\
\\
\[\begin{minipage}[b]{0.8\textwidth}
    \includegraphics[width=\linewidth]{assets/alu_4_bits.png}
    
    \label{fig:alu_4_bits}
\end{minipage}\]
Nótese que el multiplexor elige un camino u otro según OP; OP toma los valores de 00, 01, 10 y 11. En base a qué se envía como entrada de control el multiplexor decide qué entrada habilitar para dar la salida. \\
En este caso, OP: 1 0 (marcado en rojo) corresponde a la opción de realizar A AND B bit a bit

\subsection*{Timing}
En un circuito combinatorio el tiempo que tarda la salida en estabilizarse depende de la cantidad de capas de compuertas (latencia). Para enfrentar el problema usamos secuenciales.

\section*{Latchs}
Utilizan realimentación, es decir, la salida de una compuerta como entrada de otra.
\subsection*{Latch RS}
Tiene dos entradas: S (Set) y R (Reset), y dos salidas, Q y \(\bar{Q}\) y consiste en dos puertas NOR conectadas por realimentación
El circuito es consistente permanece estable \(\iff\) S = R = 0.
Tabla de verdad del Latch
\begin{figure}[h]
    \begin{subfigure}{0.4\textwidth}
        \centering
        \includegraphics[width=0.7\linewidth]{assets/latch_circuito.png}
        \label{fig:latch_circuito}
        \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \centering
    \includegraphics[width=0.5\linewidth]{assets/latch.png}
    \label{fig:latch}
    \end{subfigure}
    \end{figure}
    

Funciona como un memorizador
\begin{itemize}
    \item Cuando S está prendido entonces Q = 1.
    \item Cuando Q está prendido entonces \(\bar{Q}\) = 1.
    \item Si ninguno está prendido recuerda el estado anterior. 
    \item Si ambos están prendidos, Q = 0 y \(\bar{Q}\) = 0. Este caso no debería estar permitido porque la salida es inconsistente.
\end{itemize}

Para recordar el estado anterior usamos la notación de: \(Q \ast\) y \(\bar{Q} \ast \) \\

\textbf{Importante}: El valor de las salidas depende de la implementación del latch. Por lo tanto, un Latch con NAND no sería lo mismo que un Latch con NOR.

\subsection*{Latch JK}
Acepta todas las combinaciones posibles de las entradas.
\begin{itemize}
    \item Cuando J está prendido entonces Q = 1.
    \item Cuando K está prendido entonces \(\bar{Q}\) = 1.
    \item Si ninguno está prendido recuerda el estado anterior. 
    \item Si ambos están prendidos, niega el estado anterior (¡necesita que haya un estado anterior!)
\end{itemize}

\[\begin{minipage}[b]{0.8\textwidth}
    \includegraphics[width=\linewidth]{assets/latch_jk.png}
    \label{fig:latch_jk}
\end{minipage}\]

Cuando J y K son 1, la función realizada se denomina función de conmutación, la salida se invierte. 

El circuito oscila (estado inestable)

\subsection*{Latch D}
Es un almacén para un bit de datos. La salida del Latch D es siempre igual al valor más reciente aplicado a la entrada y por lo tanto la recuerda y la produce.

Tiene una entrada de datos y una de control.

Este circuito es estable en todos los estados pero los tiempos no se pueden predecir porque dependen de D y puede causar carreras si existe un lazo en el circuito externo

\begin{itemize}
    \item Cuando D está apagado y C está prendido, se memoriza C.
    \item Si ambos están prendidos, se memoriza D.
    \item En cualquier otro caso, devuelve el valor memorizado.
\end{itemize}

\[\begin{minipage}[b]{0.8\textwidth}
    \includegraphics[width=\linewidth]{assets/latch_d.png}
    \label{fig:latch_d}
\end{minipage}\]

\subsection*{Control de transición de estados: Clock}
\[\begin{minipage}[b]{0.8\textwidth}
    \includegraphics[width=\linewidth]{assets/clock_1.png}
    \label{fig:clock_1}
\end{minipage}\]
El clock que necesitamos utilizar es el 3ro. ¿Por qué? Porque nos interesa solamente memorizar o guardar los estados de los valores cuando el clock está en el pico. \\
No necesitamos estar constantemente escuchando cambios con el clock, sino que nos interesa solo en la subida.
\\
Para solucionar este problema, podemos utilizar un detector de pulso.
\begin{figure}[h]
    \begin{subfigure}{0.4\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{assets/detector_pulso_1.png}
        \label{fig:detector_pulso_1}
        \end{subfigure}
    \begin{subfigure}{0.7\textwidth}
        \centering
    \includegraphics[width=0.6\linewidth]{assets/detector_pulso_2.png}
    \caption{Detector de pulso implementado usando una compuerta AND. }
    \label{fig:detector_pulso_2}
    \end{subfigure}
    \end{figure}
\\ Es importante notar, que el detector de pulso dará 1 (el pico) en algunos casos porque la compuerta NOT tiene un pequeño delay para poder negar la entrada. A continuación se muestra un ejemplo de esto.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/detector_pulso_3.png}
    \label{fig:detector_pulso_3}
\end{minipage}\]
La línea punteada indica el tiempo que tardó la entrada en ser negada. En ese momento es donde se nos ejecutan los picos que nosotros necesitamos. \\
Si mandamos input = 1, el primer momento queda 1 AND 1 y el AND es verdadero, pero luego de un momento queda 1 AND 0 y ahora la señal vuelve a estar baja. Si fuese 1 AND 1 todo el tiempo tendríamos un clock constante y no necesitamos eso. \\
Todas las compuertas tienen delay porque al estar compuestas de silicio, tardan un poco en entrar en calor.\\

Veamos un ejemplo en Logisim usando registros y una ALU con el tema este de la secuencialidad a la hora de escribir en el pico del clock. \\
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/pico_1_escritura.png}
    \label{fig:pico_1_escritura}
\end{minipage}\]
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/pico_2_clock_apagado.png}
    \label{fig:pico_2_clock_apagado}
\end{minipage}\]
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/pico_3_escritura.png}
    \label{fig:pico_3_escritura}
\end{minipage}\]
\begin{itemize}
    \item Se activan las instrucciones de \texttt{Reg0\_Write}, \texttt{Reg0\_enableOut} (que permite exponer su valor a los demás) y se activa \texttt{ALU\_A\_WRITE} para que la ALU reciba el valor que expone \texttt{Reg0\_enableOut}.
    \item La primera operación que toma el clock en el flanco de subida es la escritura del número en \texttt{Registro\_00}.
    \item Al apagar el clock, todo sigue igual.
    \item Al encender el clock en el primer flanco de subida la ALU recibió el valor en \texttt{ALU\_A\_WRITE} del \texttt{Registro\_00} que expuso previamente en \texttt{Reg0\_enableOut}.
\end{itemize}
En circuitos secuenciales se niega el clock para que cada operación pueda tomarse el tiempo que necesita, caso contrario pasa basura.

\subsection*{Flip-Flop JK}
Está armado en base a Latch JK + Clock. \\
El Latch JK funcionará igual pero solo memorizará el valor sii el clock está en el flanco de subida.
\begin{itemize}
    \item Cuando J es 1 y el clock está prendido, se guarda el valor de J.
    \item Cuando K es 1 y el clock está prendido, se guarda el valor de K.
    \item Cuando el clock está apagado devuelve el valor de J/K guardado en el último pulso al clock. 
    \item Cuando el clock está apagado y J, K = 1 se niega el resultado guardado en el último pulso al clock.
    \item En cualquier otro caso, sucede el ítem anterior.
\end{itemize}
\subsection*{Flip-Flop D}
Está armado en base a Latch D + Clock. \\
El Latch D funcionará igual pero solo memorizará el valor sii el clock está en el flanco de subida.
\begin{itemize}
    \item Cuando el clock es 1, guarda el valor de D en ese instante.
    \item Cuando el clock está apagado, devuelve el valor de D guardado en el último pulso al clock. En criollo: Guarda el valor de D hasta que haya otro flanco de subida (ciclo) y guarde uno nuevo.
\end{itemize}

\[\begin{minipage}[b]{0.5\textwidth}
    \includegraphics[width=\linewidth]{assets/flip_flop_d.png}
    \label{fig:flip_flop_d}
\end{minipage}\]

Nota: \(1\uparrow\) indica que solo es se evalúa cuando está en el flanco de subida.
\subsection*{Registros}
Para poder escribir registros necesitamos una entrada de control Enable que nos permitirá decirle al Flip-Flop cuando nosotros queremos permitir que nos cambie el valor / escriba la memoria. \\
Este flag de Enable deberá ir en un AND con el Clock, entonces si Enable = 1 y el Clock está en 1, entonces se le permite al Flip Flop guardar el valor de la operación realizada.
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/flip_flop_d_enable.png}
    \label{fig:flip_flop_d_enable}
\end{minipage}\]

Recuerdo: El Flip Flop D solo almacena 1 bit. Si necesitaramos almacenar n bits (registro de n bits) necesitaríamos n Flip Flop D y UN solo Enable/Clock.

\subsection*{Componentes de Tres Estados}
Apagado, Encendido y Desconectado.
Al estado Desconectado le decimos que es de Alta Impedancia y se simboliza \textbf{Hi-Z}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/tres_estados.png}
    \label{fig:tres_estados}
\end{minipage}\]
En la materia, una combinación basura de un componente de tres estados es que haya más de una entrada de control prendida con una misma entrada de dato. Esto es porque si bien en Logisim se acepta, no tendría sentido abrir dos conductos y mandar dos datos (iguales), la corriente siempre varía en algún momento y lo haría estallar. \\

\begin{figure}[h]
    \begin{subfigure}{0.6\textwidth}
        \centering
        \includegraphics[width=0.6\linewidth]{assets/comb_basura_tres_estados.png}
        \caption{Caso basura (erróneo)}
        \label{fig:comb_basura_tres_estados}
        \end{subfigure}
    \begin{subfigure}{0.6\textwidth}
        \centering
    \includegraphics[width=0.7\linewidth]{assets/comb_basura_tres_estados_explota.png}
    \caption{Caso erróneo (explota)}
    \label{fig:comb_basura_tres_estados_explota}
    \end{subfigure}
    \begin{subfigure}{0.6\textwidth}
        \centering
    \includegraphics[width=0.6\linewidth]{assets/comb_ok_tres_estados.png}
    \caption{Caso ok}
    \label{fig:comb_ok_tres_estados}
    \end{subfigure}

    \end{figure}


\subsection*{Bus}
Nos va a servir para poder conectar varios componentes. Es una vía de n bits que van a estar conectando todos los componentes de nuestra arquitectura.
\[\begin{minipage}[b]{0.7\textwidth}
    \includegraphics[width=\linewidth]{assets/bus_componentes.png}
    \label{fig:bus_componentes}
\end{minipage}\]
Cada dispositivo sería cualquier operación, por ejemplo cada dispositivo podría ser un Flip-Flop D. \\ \\
Ej.: Si \(Dispositivo_{0}\) tendría el número 2 escrito en 4 bits (0010) y el \(Dispositivo_{1}\) tendría el número 4 escrito en 4 bits (0100) entonces el bus tendría el valor de 6. Esto es un problema, porque básicamente se está haciendo una especie de conjunción de todas las cosas y no siempre vamos a querer que se haga de esa forma. Aquí aparece un concepto importante llamado Recurso Compartido. \\ \\
Llamamos \textbf{recurso compartido} cuando tenemos más de un componente/dispositivo conectado en un mismo bus y necesitamos decidir quién usa cada componente. \\ \\
Para prender uno de los dispositivos y no los demás, bastaría con poner en 1 el dispositivo que quiero mientras que los demás en 0.
\subsection*{Reset}
Coloca en 0 el componente. Comúnmente, el reset es asincrónico.
\subsection*{Write Enable y Enable Out}
Son dos instrucciones. No pueden pasar ambas a la vez. O escribimos, o leemos.
Cada vez que hacemos el cambio de estado de Enable Out o Write Enable, en algún momento deberán volver al estado anterior.

\subsection*{Esquema de interconexión de n registros}
Ahora nos queda realizar el esquema 
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/registro_fin.png}
    \label{fig:registro_fin}
\end{minipage}\]
Utilizo 3 Flip-Flop D con la posibilidad de escribir cuando el clock está activo y un botón de reset \\
Se añade un EnableOut para que se muestre el dato almacenado con lo armado en el paso 1 \\ \\
¿Como podríamos copiar el dato de R1 a R0? 
\begin{itemize}
    \item Utilizo Enable Out en R1 - EnableOut-1 \(\leftarrow\) 1
    \item Habilito WriteEnable en R0 - WriteEnable-0 \(\leftarrow\) 1
    \item Espero que el Clock esté funcionando en R0
    \item Deshabilito WriteEnable en R0 - WriteEnable-0 \(\leftarrow\) 0
    \item Deshabilito Enable Out en R1 - EnableOut-1 \(\leftarrow\) 0
\end{itemize}
De esta manera podemos pasar datos entre registros.

\section{Máquinas de estado}
Los circuitos secuenciales pueden ser pensados formalmente como una Máquina de Estados Finitos o FSM.
Una máquina de estados queda definida por: 
\begin{itemize}
    \item Una lista de estados.
    \item Un estado inicial.
    \item Una lista de funciones que disparan las transiciones en función de las entradas. 
\end{itemize}
\newpage
\subsection*{Diagramas de estado}
Nos indican el comportamiento de los circuitos secuenciales en base al estado y como van avanzando
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/diagramas_estado.png}
    \label{fig:diagramas_estado}
\end{minipage}\]
Nota: \(x^{'}\) indica la variable negada.

\subsection*{FSM - Moore}
La salida depende solo del estado actual.
\begin{itemize}
    \item La salida siempre cambia un clock después que se dispara la condición de transición.
    \item No produce glitches a la salida.
    \item La cantidad de estados para reproducir cierto comportamiento puede ser más grande que con otro tipo de FSM.
\end{itemize}

\subsection*{FSM - Mealy}
La salida depende del estado actual y las entradas.
\begin{itemize}
    \item La salida pueda cambiar dentro del mismo clock en que se dispara la condición de transición.
    \item Produce glitches a la salida.
    \item La cantidad de estados para reproducir cierto comportamiento es más chica que en Moore.
\end{itemize}

\subsection*{Lógica de próximo estado}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/registros_flip_flops.png}
    \label{fig:registros_flip_flops}
\end{minipage}\]
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/flip_flop_registros.png}
    \label{fig:flip_flop_registros}
\end{minipage}\]

¿Qué valores deberían tener \(D_{1} \ y \ D_{0}\) para obtener los valores deseados en el tiempo t+1, es decir, \(Q_{1}(t+1) \ y \ Q_{0}(t+1)\) \\
Usamos un flip-flop D, para que en vez de usar asignaciones dependa del estado anterior.
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/suma_productos_flip_flop_d.png}
    \label{fig:suma_productos_flip_flop_d}
\end{minipage}\]
\subsection*{Lógica de salida}
Consiste en hacer foco en como se deben vincular los estados porque muchas veces no nos es suficiente inferir comportamiento solo con la salida.
Veamos un claro ejemplo donde tenemos que hacer uso de la lógica de salida porque debemos conocer el estado para poder conocer el siguiente valor. 
00, 01, 11, y 10 son salidas.
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/logica_salida_ex.png}
    \label{fig:logica_salida_ex}
\end{minipage}\]
Para poder decidir esto, usamos etiquetas de estado.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/logica_salida_etiquetas.png}
    \label{fig:logica_salida_etiquetas}
\end{minipage}\]
Nota: \(S_{n}\) n es el estado y el valor asignado es la codificacion. \\
TODO: Preguntar como hizo para calcular la suma de productos en base a los estados.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/logica_salida_suma_productos.png}
    \label{fig:logica_salida_suma_productos}
\end{minipage}\]
\section{Arquitectura}
Observación: Nosotros vamos a manejarnos con 32 registros y data de 4 bytes.\\

¿Qué constituye una arquitectura?
\begin{itemize}
    \item El conjunto de instrucciones
    \item El conjunto de registros
    \item La forma de acceder a la memoria
\end{itemize}
Observación: Utilizaremos la arquitectura Risc V como programa de Assembler en la materia. \\
Observación 2: El lenguaje ensamblador depende de cada arquitectura. Cuando un lenguaje es compilado, traduce a la arquitectura de tu equipo.
\subsection*{Pasaje de lenguaje de alto nivel a bajo nivel}
Para esto se necesitan programas de compilado, ensamblado y enlazado.
\begin{itemize}
    \item El código de alto nivel es traducido por el compilador para pasar a código de bajo nivel.
    \item El código de bajo nivel es traducido por el ensamblador y se convierte en un código objeto (archivos \textbf{.o}).
    \item El código objeto es traducido por un enlazador y termina siendo binario ejecutable.
\end{itemize}
\subsection*{Operaciones en Risc V}
Reciben el nombre de mnemónico e indica el tipo de operación que queremos realizar. \\
Las operaciones reciben: \textbf{operandos de fuente} y un \textbf{operando destino}
\[a = b + c \equiv add \ a,\ b,\ c\]
El operando destino a sería el primer parámetro del mnemónico add, mientras que los operandos fuente serían b y c.
\subsection*{Instrucciones atómicas y compuestas}
Es exactamente lo mismo que en lógica. Las operaciones se separan y deben indicarse claramente como se realizan.
Las instrucciones atómicas son aquellas que nos devuelven un valor irreducible, mientras que las instrucciones compuestas nos devuelven algo reducible. \\
Calculemos: \(a = b + c - d\)
\begin{itemize}
    \item \(add \ t,\ b,\ c\) \# t=b+c
    \item \(sub \ a,\ t, \ d\) \# a=t-d
\end{itemize}

\subsection*{Comentarios en Risc V}
Usamos \# para comenzar una línea de comentarios.
\subsection*{Registros en Risc V - Register File}
Cuenta con 32 registros que son implementados como un arreglo de memoria estática de 32 bits con varios puertos. \\
Los registros pueden nombrarse por su índice, desde x0 a x31 o según su uso habitual.
\begin{itemize}
    \item El registro zero (x0) almacena siempre el valor 0, y no puede ser escrito.
    \item Los registros s0 a s11 y los t0 a t6 se utilizan para almacenar variables.
    \item ra y de a0 a a7 tienen usos relacionados a llamadas de función.
\end{itemize}
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/PC.png}
    \label{fig:PC}
\end{minipage}\]
El registro PC es el Program Counter y lleva el registro de lo que se está ejecutando en un momento dado. \\
Hagamos el cálculo que habiamos hecho antes (a = b + c - d) pero con las variables en los registros.
\begin{itemize}
    \item \# s0 = a, s1 = b
    \item \# s2 = c, s3 = d, t0 = t
    \item \(add \ t0,\ s1,\ s2\) \# t=b+c
    \item \(sub \ s0,\ t0, \ s3\) \# a=t-d
\end{itemize}
Nota: los valores que toman las operaciones no pueden ser de 32 bits porque la operación en sí ya ocupa 5 bits. \\
Preguntar: ¿Cómo es que s0 tiene efectivamente a \textbf{a}, s1 tiene a \textbf{b}?
\subsection*{Valores inmediatos}
Son valores constantes que se utilizan como operandos. Se encuentran disponibles en la misma instrucción y no hace falta recuperar su valor a partir de un registro o desde la memoria. \\
El valor puede escribirse en decimal, hexadecimal (prefijo 0x) o binario (prefijo 0b). \\
\textbf{Los valores inmediatos son de 12 bits y se extiende con el bit de signo a 32 bits antes de operar.}
\begin{itemize}
    \item \# s0 = a, s1 = b
    \item \(addi \ s0,\ s0,\ 4\) \# a = a + 4
    \item \(addi \ s1,\ s0, \ -12\) \# b= a - 12
\end{itemize}
En este caso, el 4 y el -12 son extendidos a 32 bits para poder operar. 
\textbf{Ojo: Las operaciones que son inmediatas son fórmulas compuestas. Es decir, no toman una sola posición de memoria sino que toman varias porque son alias para operaciones compuestas. Ej: li a0, 4228 hace un lui y un addi.}
\subsection*{Asignación}
Se hace zero + lo que queremos asignar. Consideremos que s0 = i
\begin{itemize}
    \item \(addi \ s0,\ zero,\ 4\) \# i = 4
\end{itemize}
\subsection*{Valores inmediatos de 32 bits}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/valores_inmediatos_pos.png}
    \label{fig:valores_pos}
\end{minipage}\]
¿La idea sería pasar de derecha a izquierda, o pasar lo de la izquierda a la derecha? \\
¿Por qué los bits más altos son considerados ABCDE? \\
¿Cual es la regla para decir cuales son altos o bajos? (en este contexto manual)
Lo que no entiendo es, los bits mas altos están seleccionados a mano (ABCDE) y los más bajos también (123) pero no podrían ser los más altos ABCD y los más bajos E123?
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/valores_inmediatos_neg.png}
    \label{fig:valores_neg}
\end{minipage}\]
Cuando dice que la parte baja se expresa como un número negativo ¿está tratando de decir que el valor inmediato de la suma es -1657?
\subsection*{Memoria}
Se estructura y se accede como si fuera un arreglo de elementos de 32 bits (4 bytes). El acceso a memoria es significativamente más lento que el acceso a registros pero nos permite guardar más data. \\ \\
RISC V permite acceder a la memoria con índices (direcciones) de 32 bits osea 4.294.967.296 índices posibles. El índice apunta a un byte en particular. \\ \subsection*{Escritura y Lectura en Memoria}
Lectura: Instrucción lw (load word); Escritura: Instrucción sw (store word). \\ \\
Las direcciones se definen como: 
\[direccion = base + desplazamiento\]
base: valor de un registro \\
desplazamiento: constante con signo de 12 bits
\subsection*{Lectura en Memoria (asignación a variable)}
\[\begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\linewidth]{assets/leyendo_memoria.png}
    \label{fig:leyendo_memoria}
\end{minipage}\] 
lw, variable, desplazamiento(lugarEnMemoria) \\
elem = cantidad de bytes por dato \(\ast\) indice al que quiero llegar. \\
s3 tiene la posición de memoria en el registro donde está el arreglo. \\
\subsection*{Escritura en Memoria}
sw, variable, desplazamiento(lugarEnMemoria) \\
Programa: \(mem[5] = 33\) 
\begin{itemize}
    \item \# s3 = mem
    \item \(addi \ t3, \ zero,\ 33\)
    \item \(sw, \ t3, \ 20(s3)\)
\end{itemize}
El programa anterior crea una variable en el registro temporal t3, le asigna el valor de 33 y luego en la memoria posición 5 del array le asigna t3.
Preguntar: Como t3 es un registro temporal, cuando se borra luego de guardar el valor en el array? 
\subsection*{Instrucciones lógicas en RISC V}
Sean dos registros cualesquiera, las operaciones lógicas se hacen bit a bit. \\
Ejemplo de XOR entre dos registros
\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c | c | c| c|}
    \hline
    s1 & 0100 0110 & 1010 0001 & 1111 0001 & 1011 0111 \\ \hline
    s2 & 1111 1111 & 1111 1111 & 0000 0000 & 0000 0000 \\ \hline
    xor s5, s1, s2 & 1011 1001 & 0101 1110 & 1111 0001 & 1011 0111 \\
    \hline
    \end{tabular}
    \label{tab:xor}
\end{table} 
\\
Or: Combina dos registros que solo tienen asignada la parte alta y baja. Ej: \(0xFEED0000 \lor 0x0000F0CA \equiv 0xFEEDF0CA \)  
and: Limpia las partes de un registro, si quisieramos preservar solamente la parte baja de \(0xBABAC0C0\) podemos hacer \(0xBABAC0C0 \land 0x0000FFFF \equiv 0x0000C0C0\) Preguntar 
xor: Negación del valor
\subsection*{Instrucciones de desplazamiento}
\begin{itemize}
    \item sll (shift left logical): desplaza a la izquierda tantas unidades como se diga, como es logico se añaden 0's a la derecha.
    \item srl (shift right logical): desplaza a la derecha tantas unidades como se diga, como es lógico se añaden 0's a la izquierda.
    \item sra (shift right arithmetic): desplaza a la derecha tantas unidades como se diga, como es aritmético se añade el bit más significativo a la izquierda.
\end{itemize}
Nota: También existen las versiones de estas operaciones con el immediate (i) para usar una constante.

\begin{table}[h!]
    \centering
    \begin{tabular}{|c | c | c | c| c|}
    \hline
    s5 & 1111 1111 & 0001 1100 & 0001 0000 & 1110 0111 \\ \hline
    slli t0, s5, 7 & 1000 1110 & 0000 1000 & 0111 0011 & 1\textbf{000 0000} \\ \hline
    srli t0, s5, 17 & \textbf{0000 0000} & \textbf{0000 0000} & \textbf{0}111 1111 & 1000 1110\\ \hline
    srai t0, s5, 3 & \textbf{111}1 1111 & 1110 0011 & 1000 0010 & 0001 1100\\ \hline
    \end{tabular}
    \label{tab:desplazamiento_riscv}
\end{table} 
Lo que hago yo esto para hacerlo fácil, en el caso de 17 por ejemplo es: como me piden mover 17 a la derecha, borro los 17 últimos (xq no tengo espacio donde guardarlos), reordeno de a pares de 4 y despues donde faltan agrego de la izq.
\begin{itemize}
\item 1111 1111 \& 0001 1100 \& 0001 0000 \& 1110 0111
\item 1111 1111 \& 0001 110 \(\implies\) acá tengo que reordenar xq de la der no me pueden quedar 3 bits solos
\item 111 1111 \& 1000 1110 \(\implies\) reordené
\item 0000 0000 \& 0000 0000 \& 0111 1111 \& 1000 1110 \(\implies\) agregué los 0's
\end{itemize}
\subsection*{Byte en particular con desplazamiento}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/byte_desplazamiento.png}
    \label{fig:byte_desplazamiento}
\end{minipage}\] 
Preguntar, no entendi
\newpage 
\subsection*{Importancia del Program Counter}
Recordatorio: Cada dirección se incrementa en múltiplos de 4 porque las instrucciones ocupan 4 bytes. \\
El procesador ejecuta el programa almacenando la posición de memoria de la instrucción que se está ejecutando en un registro de 32 bits conocido como el Program Counter.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/importancia_pc.png}
    \label{fig:importancia_pc}
\end{minipage}\] 
El Program Counter va cambiando la instrucción que está ejecutando gracias al aviso del procesador.
\subsection*{Control del flujo de ejecución}
Se va pisando el PC (Program Counter). 

\subsection*{Etiquetas en RISC V}
Nos permiten ponerle nombre a subproblemas; No ocupan memoria.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/etiquetas_beq.png}
    \label{fig:etiquetas_beq}
\end{minipage}\] 

\subsection*{Orden que toman las operaciones en memoria}
Las posiciones de memoria que ocupa cada instrucción se leen de arriba hacia abajo sin importar si hay un salto o no.
Ver ejercicio en \hyperref[subsec:TPRVC]{anexo} 
\subsection*{Saltos condicionales}
Instrucciones que pisan el PC: 
\begin{itemize}
    \item beq(branch if equal): reemplaza el PC si los dos operandos son iguales.
    \item bne(branch if not equal): reemplaza el PC si los dos operando son distintos.
    \item blt(branch if less than): reemplaza el PC si el primer operando es menor que el segundo.
    \item bge(branch if greather than or equal): reemplaza el PC si el primer operando es mayor o igual al segundo.
\end{itemize}
\subsection*{Saltos incondicionales}
Instrucciones que pisan el PC: 
\begin{itemize}
    \item j (jump): actualiza el valor del PC con el operando provisto (inmediato de 20 bits extendidos en signo a 32)
    \item jal (jump and link): que almacena el valor actual del PC en el registro indicado en el primer operando y actualiza el valor del PC con el segundo operando (este se usa para llamar a una función, terminar y volver a ese link anterior).
\end{itemize}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/jump.png}
    \label{fig:jump}
\end{minipage}\] 
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/jump_while.png}
    \label{fig:jump_while}
\end{minipage}\] 
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/while_j.png}
    \label{fig:while_j}
\end{minipage}\] 
\begin{itemize}
    \item se inicializa una variable permanente con el valor zero.
    \item se inicial la variable temporal en 200.
    \item el for se realiza mientras s1 sea menor a t2.
    \item se inicializa una variable temporal t0 con el valor de s1 (¿que seria el 2, entiendo que un desplazamiento logico hacia la izquierda pero para que?).
    \item a la variable temporal t0 se le suma s0 (s0?)
    \item se inicializa una variable temporal t0 que tiene el valor de t0 en el indice 0.
    \item a la variable temporal t1 se le suma 10 (scores[i] + 10)
    \item se cambia el valor de t1 indicando que tiene el valor de t0 en el indice 0.
    \item se modifica la variable de s1 (incrementadora) sumandole 1 unidad.
\end{itemize}
\subsection*{Funciones}
En RISC V la función llamadora puede utilizar los registros del a0 hasta a7 para enviar argumentos. La función llamada usa a0 para devolver el resultado. \\
La función llamada no debe interferir con el estado de la función llamadora, es decir, debe respetar los valores de los registros (s0 a s11) y el registro ra (dirección de retorno). \\
El stack de la función llamadora debe mantenerse invariante al ingresar a la función llamada.
\subsection*{Llamando funciones \& enviando parámetros}
Los inicializamos en la función llamadora, y luego en la función llamada simplemente accedemos a ellos.
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/funciones_risc_2.jpg}
    \label{fig:funciones_risc_2}
\end{minipage}\]

Nótese que cuando hacemos jal dif sumas, le estamos mandando la posición donde quedó antes de llamar a la función, entonces luego en la llamada podemos usar ra y volver a ese punto.
\subsection*{Pila (stack)}
Es una parte de la memoria que se utiliza para almacenar información temporaria. La pila suele comenzar en las direcciones altas de la memoria y va tomando las direcciones inmediatamente más bajas. 
RISC V recomienda el registro de su Stack Pointer (sp)
\subsection*{Reglas de llamada}
\begin{itemize}
    \item Regla para la llamadora: Antes de llamar debe guardar los valores de los registros temporarios que necesite utilizar al retornar (t0-t6, a0-a7)
    \item Regla para la llamada: Si va a utilizar los registros permanentes (s0-s11, ra) debe guardarlos al comenzar y restaurarlos antes de retornar
\end{itemize}
\section*{Compilación, ensamblado y ejecución}
\subsection*{El mapa de memoria}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/memory_map.png}
    \label{fig:memory_map}
\end{minipage}\]
\subsection*{Directivas de ensamblado}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/directivas_ensamblado.png}
    \label{fig:directivas_ensamblado}
\end{minipage}\]
\subsection*{Inicialización de datos}
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/inicializacion_datos.png}
    \label{fig:inicializacion_datos}
\end{minipage}\]
Inicialización de datos en la sección .data que va a ubicar la información en lo que el mapa se muestra como Global Data.

Programa final con inicialización de los datos en RISC V
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/risc_v_ejercicio.png}
    \label{fig:risc_v_ejercicio}
\end{minipage}\]

\section*{Cosas a utilizar en Risc V (machete)}

Página 21 Guia Práctica de Risc V
\[\begin{minipage}[b]{0.6\textwidth}
    \includegraphics[width=\linewidth]{assets/registros_riscv.png}
    \label{fig:registros_riscv}
\end{minipage}\]

Página 18 de Guia Práctica de Risc V
\[\begin{minipage}[b]{0.8\textwidth}
    \includegraphics[width=\linewidth]{assets/ins_risc_v.png}
    \label{fig:ins_risc_v}
\end{minipage}\]
Risc V cheatsheet
\[\begin{minipage}[b]{0.8\textwidth}
    \includegraphics[width=\linewidth]{assets/32_bit_instruction_rirsc_v.png}
    \label{fig:32_bit_instruction_rirsc_v}
\end{minipage}\]

\section*{Anexo - Ejercicios}
\subsection*{Hexa - Binario - Risc V}
\textbf{Decodifique a instrucciones de Risc-V} \\
1. $0x00700293$ \\ 

\textbf{Pasamos cada numero hexadecimal a binario, cada hexa son 4 bits de binario} \\ 
$0000 \ 0000 \ 0111 \ 0000 \ 0000 \ 0010 \ 1001 \ 0011$ \\

\textbf{Ahora sabemos que el opcode son los últimos 7 bits, reagrupamos} \\ 
$0000 \ 0000 \ 0111 \ 0000 \ 0000 \ 0010 \ 1 \ 0010011$ \\

\textbf{Vemos que familia de operación corresponde a 0010011 en la tabla de la Figura 2.3. La familia es $ \implies $ I} \\
\textbf{Ahora vemos que lo que le sigue es el rd, por lo tanto reagrupo} \\
$0000 \ 0000 \ 0111 \ 0000 \ 0000 \ 00101 \ 0010011$ \\

\textbf{Lo que sigue ahora es la func, que son 3 bits, por lo tanto reagrupo} \\
$0000 \ 0000 \ 0111 \ 0000 \ 0 \ 000 \ 00101 \ 0010011$ \\

\textbf{Lo que sigue ahora es el rs1 que toma 5 bits, por lo tanto reagrupo} \\ 
$0000 \ 0000 \ 0111 \ 00000 \ 000 \ 00101 \ 0010011$ \\ 

\textbf{Lo que sigue ahora es el immediate (20 a 31) porque estamos en la familia del I, por lo tanto reagrupo} \\ 
$0000 0000 0111 \ 00000 \ 000 \ 00101 \ 0010011$ \\

\textbf{Por último, traducimos a operaciones de Risc-V} \\ 
0010011 000: ADDI  \\ 
00101 rd: pasado a decimal es 5, por lo tanto en la tabla de registros x5 es t0. \\
00000 rs1: pasado a decimal es 0, por lo tanto en la tabla de registros x0 es zero. \\
0x007: es donde se guarda en memoria, eso en decimal es 7 por lo tanto en la tabla de registros x7 es t2. \\ 

\textbf{Luego, juntamos todos los operandos en Risc-V} \\ 
ADDI t0, zero, t2

\subsection*{Traducción de programa de Risc V a castellano y observando las posiciones de memoria de instrucciones}
\label{subsec:TPRVC}
\begin{lstlisting}
    li a0, 4228 <- 0x0000 a 0x0008 (0 a 8) sin incluir
    li a1, 2114 <- 0x0008 a 0x0010 (8 a 16) sin incluir
    jal ra, resta <- 0x0010
    fin: 
        beq zero, zero, fin <- 0x0014 
    resta: 
    prologo:
        addi sp, sp, -4 <- 0x0018
        sw ra, 0(sp) <- 0x001c
        sub a0, a0, a1 <- 0x0020
        beq a0, zero, epilogo <- 0x0024
    sigo: 
        jal ra, resta <- 0x0028
    epilogo:
        lw ra, 0(sp) <- 0x002c
        addi sp, sp, 4 <- 0x0030
        ret <- 0x0034
\end{lstlisting}
\textbf{Nota}: Recordar que las etiquetas no son funciones, son simplemente instrucciones que se leen. Es decir, por ejemplo, cuando va por prologo y llega a beq si es falso ejecuta sigo, pero no es necesario llamarla sino que lo de jal ra, resta es parte del prologo solo que se le dio un subnombre. Todo se lee de arriba hacia abajo, por lo tanto a epilogo tambien estaría dentro de prologo por así decirlo pero nunca llega porque el beq si es falso hace llamada recursiva. Solo llega a epilogo y cambia el PC si el beq es true. \\ 
¿Qué hace este código? línea por línea
\begin{itemize}
    \item li a0, 4228: carga el valor de 4228 en el registro a0. Internamente son dos operaciones, lui y addi por lo tanto ocupan desde 0x0000 a 0x0008 (sin incluir).
    \item li a1, 2114: carga el valor de 2114 en el registro a1. Internamente son dos operaciones, lui y addi por lo tanto ocupan desde 0x0000 a 0x0010 (sin incluir)
    \item jal ra, resta: salta a la etiqueta de resta y guarda la dirección de retorno en ra (para que el return de resta vuelva acá)
    \item addi sp, sp, -4: reserva 4 bytes en el stack pointer bajándolo. Esto es un caso específico, podría bajar 8 bytes si se quisiera pero como solo quiere escribir un solo valor, basta con 4 bytes. Importante que luego de hacer todo el stack debe volver a su posición original.
    \item sw: guarda ra en la primera posición del stack pointer. esto es porque luego cuando salta a epilogo tiene que saber bien a donde volver.
    \item sub: guarda en a0 la resta entre a0 y a1.
    \item beq: verifica si a0 es igual a zero, si es igual a cero salta a epilogo, caso contrario hace una llamada recursiva nuevamente a resta.
    \item sigo: si beq es falso llega acá, hace la llamada recursivamente como en la inicial mandando un nuevo estado.
    \item lw: se guarda en ra el valor que estaba en 0(sp) cuando lo guardamos antes.
    \item addi: vuelve a subir el stack a su posicion inicial porque ya no necesitamos hacer nada (nótese que es importante que subimos dejando todo como estaba pero nuestro ra que habiamos guardado antes en la primera pos lo recuperamos con el lw)
    \item ret: vuelve a jal ra, resta y ejecuta fin.
    \item el programa termina si zero es igual a zero pero luego ejecuta fin recursivamente. (no termina nunca)
\end{itemize}
Pasemos esto a TypeScript: A modo ilustrativo, si la función recursiva termina retornará true, caso contrario se quedaría colgada. En estos casos siempre termina xq los números dan.
\begin{lstlisting}
    const a0:number = 4228;
    const a1:number = 2114;

    const resta = (a0: number, a1: number): number | boolean => {
        if(a0 - a1 == 0){
            return true;
        }
        else{
            return resta(a0-a1, a1);  
        }
    }

    const res = resta(a0, a1);
    console.log(res); //true
\end{lstlisting}





\end{document}